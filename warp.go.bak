package main

import (
	"bytes"
	"crypto/ecdh"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"time"

	"wiw-go/config"
	"wiw-go/proxy"
	"wiw-go/ui"

	"github.com/botanica-consulting/wiredialer"
	tea "github.com/charmbracelet/bubbletea"
)

const (
	CFWarpRegURL = "https://api.cloudflareclient.com/v0a2025/reg"
)

type cfRegisterRequest struct {
	TOS      string `json:"tos"`
	Key      string `json:"key"`
	Referrer string `json:"referrer,omitempty"`
}

type cfRegisterResponse struct {
	ID      string `json:"id"`
	Token   string `json:"token"`
	Account struct {
		License string `json:"license"`
	} `json:"account"`
	Config struct {
		ClientID string `json:"client_id"`
		Peers    []struct {
			PublicKey string `json:"public_key"`
		} `json:"peers"`
		Interface struct {
			Addresses struct {
				V4 string `json:"v4"`
				V6 string `json:"v6"`
			} `json:"addresses"`
		} `json:"interface"`
	} `json:"config"`
}

type WarpResponse struct {
	Client string
	V4     string
	V6     string
	Key    string // Server Public Key
	Secret string // Client Private Key
}

func generateKeys() (string, string, error) {
	curve := ecdh.X25519()
	privKey, err := curve.GenerateKey(rand.Reader)
	if err != nil {
		return "", "", err
	}
	pubKey := privKey.PublicKey()

	privB64 := base64.StdEncoding.EncodeToString(privKey.Bytes())
	pubB64 := base64.StdEncoding.EncodeToString(pubKey.Bytes())

	return privB64, pubB64, nil
}

func fetchWarpConfig() (WarpResponse, error) {
	privKey, pubKey, err := generateKeys()
	if err != nil {
		return WarpResponse{}, fmt.Errorf("key generation failed: %v", err)
	}

	tos := time.Now().Format(time.RFC3339)

	reqPayload := cfRegisterRequest{
		TOS: tos,
		Key: pubKey,
	}
	jsonPayload, err := json.Marshal(reqPayload)
	if err != nil {
		return WarpResponse{}, fmt.Errorf("payload marshal failed: %v", err)
	}

	req, err := http.NewRequest("POST", CFWarpRegURL, bytes.NewBuffer(jsonPayload))
	if err != nil {
		return WarpResponse{}, err
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return WarpResponse{}, fmt.Errorf("http request failed: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return WarpResponse{}, fmt.Errorf("failed to read response body: %v", err)
		}
		return WarpResponse{}, fmt.Errorf("API returned non-200 status: %d, body: %s", resp.StatusCode, string(body))
	}

	var cfResp cfRegisterResponse
	if err := json.NewDecoder(resp.Body).Decode(&cfResp); err != nil {
		return WarpResponse{}, fmt.Errorf("failed to decode response: %v", err)
	}

	if len(cfResp.Config.Peers) == 0 {
		return WarpResponse{}, fmt.Errorf("no peers found in response")
	}

	return WarpResponse{
		Client: cfResp.Config.ClientID,
		V4:     cfResp.Config.Interface.Addresses.V4,
		V6:     cfResp.Config.Interface.Addresses.V6,
		Key:    cfResp.Config.Peers[0].PublicKey, // Server's Public Key
		Secret: privKey,                          // Our Private Key
	}, nil
}

func main() {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Fetch WARP config
	warpConfig, err := fetchWarpConfig()
	if err != nil {
		log.Fatalf("Error fetching WARP config: %v", err)
	}

	// Resolve the endpoint hostname
	ips, err := net.LookupIP("engage.cloudflareclient.com")
	if err != nil {
		log.Fatalf("could not resolve endpoint: %v", err)
	}
	endpoint := fmt.Sprintf("%s:2408", ips[0].String())

	// Generate WireGuard config
	wgConfig := fmt.Sprintf(`[Interface]
PrivateKey = %s
Address = %s/32
Address = %s/128
DNS = 8.8.8.8
[Peer]
PublicKey = %s
AllowedIPs = 0.0.0.0/0
Endpoint = %s
`, warpConfig.Secret, warpConfig.V4, warpConfig.V6, warpConfig.Key, endpoint)

	// Create a temporary config file
	tmpfile, err := os.CreateTemp("", "wireguard-config")
	if err != nil {
		log.Fatal(err)
	}
	defer os.Remove(tmpfile.Name())
	if _, err := tmpfile.Write([]byte(wgConfig)); err != nil {
		log.Fatal(err)
	}
	if err := tmpfile.Close(); err != nil {
		log.Fatal(err)
	}

	// Create a new Dialer
	dialer, err := wiredialer.NewDialerFromFile(tmpfile.Name())
	if err != nil {
		log.Fatalf("could not create dialer: %v", err)
	}

	// Create the mixed proxy server
	server := proxy.NewServer(cfg, dialer.DialContext)

	// Create and run the TUI
	model := ui.NewModel(cfg, server)
	p := tea.NewProgram(model, tea.WithAltScreen())

	if _, err := p.Run(); err != nil {
		fmt.Printf("Error running program: %v\n", err)
		os.Exit(1)
	}
}
